# Демонстрационный стенд
Просто чтобы показать, как можно делать дивный новый мосэкомониторинг.
## Состав
В этом репозитории конфиг для nginx, приложение с картой на next.js и заправщик redis'а на go. Wordpress и redis подняты на виртуальной машине virtualbox, стандартная сборка на ubuntu server.  
Для redis сделан проброс портов 127.0.0.1:6379 => virtualnat:6379  
Для апача сделан проброс портов 127.0.0.1:3002 => virtualnat:80  
## Как работает
В nginx описан интерфейс для получения значений из redis по любому ключу. В самом redis лежат как объекты (в json), так и разыменованные значения из этих объектов.  
Жизненный цикл:
 - Данные выбираются из исходной базы и кладутся в redis
 - Описание точек отдается wordpress с SSI-тегами вместо данных точек
 - Nginx заменяет SSI-вызовы на данные из redis, кешируя всё на свете всерьёз и надолго
 - ...
 - PROFIT!!!
 - Карты и графики забирают данные XHR-запросами, для них всё хранится в json

В WP для демонстрации добавлено несколько строк прямо в код страницы:
```
<hr />
<ul>
        <li>Redis - get value by key 1: <!--#include virtual="/get?q=items__0__name" wait="yes" --></li>
        <li>Redis - get value by key 2: <!--#include virtual="/get?q=items__1__name" wait="yes" --></li>
        <li>Redis - get value by key 3: <!--#include virtual="/get?q=items__2__name" wait="yes" --></li>
        <li>Redis - get array by key: <!--#include virtual="/get?q=items" --></li>
</ul>
<hr />
```
Это просто демонстрация работы со значениями из redis. Делать прям точную копию блоков из оригинального проекта мне стало лень.  
Надо обратить внимание на параметр wait - он указывает, что надо отработать вызов в синхронном режиме. Если его пропускать - получится каша из вызовов, в SSI всё очень плохо с асинхронностью. Впрочем, php всё равно синхронно работает.  
### Обновление данных
Oracle => backend => redis => nginx => пользователь  
Скрипт (в прототипе - [программа на go](backend/README.md)) выбирает данные из оракловой базы, в формате json сохраняет нужные объекты в редисе, разыменовывает и сохраняет с композитными ключами все конечные (и промежуточные по необходимости) вершины в деревьях объектов. Время жизни объектов в редисе можно установить в сутки, это достаточный запас времени для самого нетребовательного SLA.  
Справочная информация об объектах, отсутствующая в оракловой базе (описания, названия, сопутствующая информация), хранится в базе WP.  
В nginx реализован [интерфейс для чтения из редиса](nginx/README.md), простой как семейные трусы.  
### Работа приложения
WP => DB => nginx  
На нелёгкую долю вордпресса остаётся только генерация новостных страничек. И этого вполне достаточно. Данные о точках также лежат где-то рядом с вордпрессом, чтобы ему, бедняге, проще было  
Next.js => nginx  
Next.js рисует карту и графики. Прям страницы целиком. Стили можно забирать из вордпресса, или делать свои. Тут сделана [простенькая гугловая карта](frontend/README.md) с такой же кастомизацией, как в оригинале. Просто чтобы показать, насколько легко тут это делать.  
## Почему так
Кажется, этот сайтег будет очень часто показывать редко меняющиеся данные, причём совсем без пользовательского контента. Поэтому все эти жизненно важные данные можно брать из in-memory хранилища, запихивая их туда с нужной периодичностью. Redis кажется подходящим вариантом, потому что умеет expiration time у записей и имеет довольно-таки приличный модуль для nginx. Nginx, в свою очередь, нужен в качестве удобного и легко масштабируемого proxy.  
